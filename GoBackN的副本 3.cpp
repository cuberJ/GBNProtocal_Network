#include<stdio.h>#include<string.h>#include"protocol.h"#include"datalink.h"#define DATA_TIMER 2800#define ACK_TIMER 240                                      #define MAX_SEQ 7//定义帧的类型，ack号，数据，序号，冗余typedef struct FRAME{	unsigned char kind;	unsigned char ack;	unsigned char seq;	unsigned char data[PKT_LEN];	unsigned int padding;}FRAME;//定义了接收窗口，发送窗口，缓存区有关的变量int physics_ready = 0;unsigned char ack_expected = 0;unsigned char next_frame_to_send = 0;unsigned char frame_expected = 0;unsigned char nbuffer = 0;unsigned char out_buffer[MAX_SEQ + 1][PKT_LEN], in_buf[PKT_LEN];//给数据帧添加CRC校验和并向物理层发送该帧void put_frame(unsigned char *frame, int len){	*(unsigned int *)(frame + len) = crc32(frame, len);	send_frame(frame, len + 4);	physics_ready = 0;}//判断收到的ack序号是否在发送窗口内int between(unsigned char a, unsigned char b, unsigned char c){	if ((a <= b) && (b < c) || (c < a) && (a <= b) || (b < c) && (c < a))		return 1;	else		return 0;}//发送数据帧void send_data( unsigned char frame_nr, unsigned char frame_expected, unsigned char buffer[][PKT_LEN]){	FRAME f;	f.kind = FRAME_DATA;	f.ack = (frame_expected + MAX_SEQ) % (MAX_SEQ + 1);                                     //回复另一端的ack序号	f.seq = frame_nr;                                                                   //相当于next_frame_to_send	memcpy(f.data, buffer[frame_nr], PKT_LEN);	dbg_frame("Send DATA %d %d, ID %d\n", f.seq, f.ack, *(short *)f.data);	put_frame((unsigned char *)&f, 3 + PKT_LEN);                                        //传递给物理层	start_timer(frame_nr, DATA_TIMER);                                                  //对发送区的每一个数据开一个定时器	//physics_ready = 0;                                                                       //物理层不可用	stop_ack_timer();}void send_ack(unsigned char frame_nr, unsigned char frame_expected, unsigned char buffer[][PKT_LEN]){	FRAME f;	f.kind = FRAME_ACK;	f.ack = (frame_expected + MAX_SEQ) % (MAX_SEQ + 1);	dbg_frame("Send ACK %d\n", f.ack);	put_frame((unsigned char *)&f, 2);	//physics_ready = 0;                                                                       //物理层不可用	stop_ack_timer();}//主函数int main(int argc, char **argv){	int event, arg, len = 0, i;	FRAME f;	protocol_init(argc, argv);	lprintf("CWN:\n");	enable_network_layer();                                                                  //使物理层可用	while (1)	{		event = wait_for_event(&arg);                                                        //一直等待事件，按照不同的事件处理		switch (event)		{		case NETWORK_LAYER_READY:			dbg_event("NETWORK_LAYER_READEY;\n");			get_packet(out_buffer[next_frame_to_send]);			nbuffer++;                                                                   //发送窗口变大			dbg_frame("------Sending DATA %d %d;\n", next_frame_to_send, (frame_expected + MAX_SEQ) % (MAX_SEQ + 1));			//log_printf("------Sending DATA %d %d;\n", next_frame_to_send, (frame_expected + MAX_SEQ) % (MAX_SEQ + 1));			send_data(next_frame_to_send, frame_expected, out_buffer);      //发送帧			next_frame_to_send = (next_frame_to_send + 1) % (MAX_SEQ + 1);               //下一个待发送序号增加			break;		case PHYSICAL_LAYER_READY:			physics_ready = 1;			break;		case FRAME_RECEIVED:			dbg_event("FRAME_RECEIVED;\n");			len = recv_frame((unsigned char *)&f, sizeof(f));			if (len < 5 || crc32((unsigned char *)&f, len) != 0)                         //判断检验码是否正确			{				dbg_frame("RECEIVE ERROR, Bad Checksum;\n");				break;			}			while (between(ack_expected, f.ack, next_frame_to_send))                    //判断接收的ack是否在发送窗口内 			{				nbuffer--;				stop_timer(ack_expected);				ack_expected = (ack_expected + 1) % (MAX_SEQ + 1);			}			if (f.kind == FRAME_DATA)                                                   //收到的是数据帧			{				dbg_frame("------RECEIVE DATA %d %d, ID %d\n", f.seq, f.ack, *(short*)f.data);				//log_printf("------RECEIVE DATA %d %d, ID %d\n", f.seq, f.ack, *(short*)f.data);				if (f.seq == frame_expected)				{					dbg_frame("Recv DATA %d %d, ID %d\n", f.seq, f.ack, *(short *)f.data);					memcpy(in_buf, f.data, len - 7);					put_packet(in_buf, len - 7);                                       //上交给网络层					frame_expected = (frame_expected + 1) % (MAX_SEQ + 1);					start_ack_timer(ACK_TIMER);				}			}						if (f.kind == FRAME_ACK)				dbg_frame("RECEIVE ACK %d\n", f.ack);			break;		case DATA_TIMEOUT:                                                            //数据超时			dbg_event("DATA %d timeout\n", arg);			next_frame_to_send = ack_expected;                                        //回退n步重传			for (i = 1; i <= nbuffer; i++)			{				send_data(next_frame_to_send, frame_expected, out_buffer);				next_frame_to_send = (next_frame_to_send + 1) % (MAX_SEQ + 1);			}			break;		case ACK_TIMEOUT:                                                             //在一定时间内没有返回流量，发送ACK帧（结合了选择重传协议）			dbg_event("ACK %d timeout\n", arg);			send_ack(0, frame_expected, out_buffer);			break;		}		if (nbuffer < MAX_SEQ&&physics_ready)                                             //物理层准备好且发送窗口小于最大窗口大小			enable_network_layer();		else			disable_network_layer();	}}
